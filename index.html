<hr />
<h2>layout: post
title: Struct vs. Class in .NET</h2>
<p><strong>Lately</strong>, I've made a very important mistake while using structs in our persistency system(save/load game).
So I wanted to write this post, which may help others, especially <strong>Unity</strong> developers. Since they mostly use C#
in their programs.</p>
<p>So what is the difference between a <strong>struct</strong> and a <strong>class</strong>?
Everybody should and probably do know by heart that, struct is a <em>value type</em> and class is a <em>reference type</em> in C#.
The things is most people do not know what this means and what are the effects.
I am going to give some examples to explain these effects.</p>
<ul>
<li>The <strong>new</strong> keyword. You can create a struct without using the <strong>new</strong> keyword, but then you need to assign all of the fields manually</li>
</ul>
<pre><code>struct MyStruct
{
	public int a;
}
MyStruct myStruct;
myStruct.a = 1; // Don't do this and you are going to get a compile error
</code></pre>
<p>If you use the new keyword, then the fields will be assigned to their default values. (e.g. 0 for int)</p>
<ul>
<li>
<p>Extension methods for structs won't modify the actual object
{% highlight ruby %}
public static void UpdateA(this MyStruct ms)
{
ms.a += 1; // The passed ms object's field 'a' is still 1, remember pass by value
}
{% endhighlight %}</p>
</li>
<li>
<p>Still a result of being a value type, you should be careful with <strong>recursion</strong>
{% highlight ruby %}
public static MyStruct RecursiveA(MyStruct ms)<br />
{<br />
ms.a += 1;
if (ms.a &lt; 10)
{
RecursiveA(ms);
}
return ms;
}</p>
</li>
</ul>
<p>ms = RecursiveA(ms);
{% endhighlight %}</p>
<p>The function above will still terminate when ms.a is 10 but the value of the actual ms.a will be 1.
You can solve this problem by using a class of course or you can assign ms inside the function like this.</p>
<p>{% highlight ruby %}
public static MyStruct RecursiveA(MyStruct ms)<br />
{<br />
ms.a += 1;
if (ms.a &lt; 10)
{
ms = RecursiveA(ms);
}
return ms;
}
{% endhighlight %}</p>
<ul>
<li>If you use the <strong>ref</strong> keyword, the struct will be passed by reference(its location in memory)
{% highlight ruby %}
public static MyStruct RecursiveA(ref MyStruct ms)<br />
{<br />
ms.a += 1;
if (ms.a &lt; 10)
{
RecursiveA(ref ms);
}
return ms;
}
// When this terminates the value of ms.a will be 10
RecursiveA(ref ms);
{% endhighlight %}</li>
</ul>
<h3>Conclusion</h3>
<p>I think it is clear that a mutable struct is not a good idea. They are good for storing read-only data. Whenever you need mutable data, you should use a class instead of a struct.</p>
<p>If you think that this blog post is wrong or missing, please send me a message.</p>
